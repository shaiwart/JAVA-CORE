# Thread Communication in Java (wait, notify, notifyAll)

When multiple threads share the same resource, sometimes one thread must **pause and let another thread do work**, then **resume later**.
This coordination is called **inter-thread communication**.

Java provides three methods for this:

* `wait()`
* `notify()`
* `notifyAll()`

These methods belong to **java.lang.Object** because **every object can act as a lock (monitor)**.

---

# Why wait() is needed

Imagine:

Thread A needs some data.
Thread B produces that data.

If A keeps checking in a loop, CPU is wasted.
Instead, A should **wait** and B should **notify** when ready.

---

# Basic Rule (Very Important)

These methods must be called:

1. Inside a **synchronized block or method**
2. On the **same object whose lock is used**

Otherwise Java throws:

`IllegalMonitorStateException`

---

# How wait() works internally

When a thread calls:

```
wait()
```

Java does 3 things:

1. Releases the lock
2. Moves the thread to the **wait pool**
3. Thread sleeps until notified

This is why other threads can enter the synchronized block.

---

# How notify() works

When another thread calls:

```
notify()
```

Java does:

1. Picks one thread from wait pool
2. Moves it to **lock-seeking state**
3. Thread runs only after acquiring lock

Important:
Notify does NOT release the lock immediately.
Lock is released only when synchronized block ends.

---

# How notifyAll() works

Same as notify, but:

* Wakes **all waiting threads**
* They compete for the lock

Used when multiple threads depend on same condition.

---

# Example: Producer–Consumer (Simple Version)

## Shared resource

```java
class SharedBuffer {
    private int data;
    private boolean available = false;

    public synchronized void produce(int value) throws InterruptedException {
        while (available) {
            wait();  // wait until data is consumed
        }

        data = value;
        available = true;
        System.out.println("Produced: " + data);

        notify(); // wake consumer
    }

    public synchronized void consume() throws InterruptedException {
        while (!available) {
            wait(); // wait until data is produced
        }

        System.out.println("Consumed: " + data);
        available = false;

        notify(); // wake producer
    }
}
```

---

## Producer Thread

```java
class Producer extends Thread {
    private SharedBuffer buffer;

    Producer(SharedBuffer buffer) {
        this.buffer = buffer;
    }

    public void run() {
        try {
            buffer.produce(10);
        } catch (InterruptedException e) {}
    }
}
```

---

## Consumer Thread

```java
class Consumer extends Thread {
    private SharedBuffer buffer;

    Consumer(SharedBuffer buffer) {
        this.buffer = buffer;
    }

    public void run() {
        try {
            buffer.consume();
        } catch (InterruptedException e) {}
    }
}
```

---

## Main

```java
public class Main {
    public static void main(String[] args) {
        SharedBuffer buffer = new SharedBuffer();

        new Consumer(buffer).start();
        new Producer(buffer).start();
    }
}
```

---

# Execution Flow

1. Consumer starts first
   → no data
   → calls `wait()`
   → releases lock

2. Producer runs
   → produces data
   → calls `notify()`

3. Consumer wakes up
   → acquires lock
   → consumes data
---

# Difference Between wait() and sleep()

| Feature            | wait()               | sleep()        |
| ------------------ | -------------------- | -------------- |
| Releases lock      | Yes                  | No             |
| Defined in         | Object               | Thread         |
| Needs synchronized | Yes                  | No             |
| Used for           | Thread communication | Delay / timing |

---

# Example to Understand Difference

## sleep()

```java
synchronized(this) {
    Thread.sleep(5000);
}
```

Thread:

* Holds lock for 5 seconds
* Other threads blocked

---

## wait()

```java
synchronized(this) {
    wait();
}
```

Thread:

* Releases lock immediately
* Other threads can run

---

# Wait Pool vs Lock Pool

When thread calls:

```
wait()
```

Thread goes to:
**Wait Pool**

After notify:
Thread moves to:
**Lock Pool (Seeking Lock)**

Only after getting lock:
Thread resumes execution

---

# notify vs notifyAll — When to use what?

Use `notify()`:

* Only one thread should proceed

Use `notifyAll()`:

* Multiple threads depend on same condition
* Safer in complex systems

Real-world frameworks almost always use `notifyAll()` to avoid deadlocks.

---

# Interview-Level Summary

If interviewer asks:

Inter-thread communication in Java is achieved using:

* wait()
* notify()
* notifyAll()

Rules:

* Must be inside synchronized block
* wait releases lock
* notify wakes waiting threads
* notifyAll wakes all waiting threads

Difference:

* wait releases lock
* sleep does not release lock

---

## Thread resumes after wait ( )
When a thread calls wait(), it resumes execution from the same point where it called wait(), not from the beginning of the method.
This is similar to sleep() in that sense—but the key difference is that wait releases the lock, while sleep does not.

```java
synchronized(lock) {
    while (!condition) {
        lock.wait();
    }

    // continues here when condition becomes true
}

// Here the thread resumes after wait(),
// but the loop checks the condition again,
// which sometimes gives the impression that
// execution restarted—but actually it just re-evaluates the loop.
```

**Which thread is resumed after notify**
notify() - wakes one arbitrary thread from the wait pool (not guaranteed which one).
notifyAll() - wakes all waiting threads, and then they compete to acquire the lock.

